# 看源码得技巧

## 1. 基础语法

### using
* `using SafeMath for *;` 表示将这个库应用于所有它支持的数据类型上

### address
* solidity中地址分为两大类：
  * EOA: 外部地址，一版是用户钱包之类
  * 合约地址： 包括代币、智能合约等
* address(0): 在以太坊中表示以太币(eth) 的地址
* address(this)：表示本合约地址

### 合约与接口
* 通过自己编写Token 合约，里面写虚方法，就可以实例化来源五花八门的代币token， 类似于IERC20接口，但是自己还可以完全控制。 EtherDelta 就是这么做的。
* 在合约中各种入参和执行步骤的检查，可以用 require 包裹返回值为bool的操作， 中间一旦出现异常，直接回滚
* 存入金额操作强调链上状态优先，即先转账成功我再改账本。 转出操作强调合约内部状态优先，改完账本再转账
  * 转出这么搞是因为我们转出需要调用第三方代币的transfer方法，而第三方transfer是不可信的， 它可以反调我们的转账方法，在没有改账本前多次转出代币，而账本只改一次， 这种就叫**重入攻击**
  * 转入这么搞是可以理解和转出的操作相反，即可保证合约状态的正常。
* 




## 2. 实际开发

### 2.1 DEX App

#### 2.1.0 状态定义
* 管理员地址，当操作需要只有管理员才能完成时，管理员地址会提供给校验权限修饰器对msg.sender进行比对
* 收费账户， DEX app 不是做公益，要收手续费赚钱，放手续费的地方
* 费率状态：一般设计为两头吃，对卖方收费费率， 对买方收费费率
* 交易金记账本： 推荐数据结构为mapping ， key 为代币token,  value 为  mapping(用户地址， 金额)  记录某种币下各用户的金额
* 订单记账本： 数据结构为mapping

#### 2.1.1 事件定义
> 要突出业务上的关键操作， 用户的行为，包含足够的信息， 便于查询， 可以从以下角度去分析
* 关键操作
  * 订单的操作： 挂单 取消订单 成交
  * 资金流动： 充值 提现
  * 关键合约状态变化
  * 合约自身更新
* 用户行为(和关键操作有重合)
  * 挂单
  * 撤单
  * 买入
  * 充值：和游戏等充值不同，用户可以提现
  * 提现
  * 账户变化
* 事件包含信息： 从前端和外部工具角度，去暴露对应的数据
* 巧妙利用最多3个indexed 事件索引， 提升查询效率

#### 2.1.2 函数功能
* 初始化
  * 设置管理员地址
  * 设置各种交易收费费率
  * 设置收取交易费的钱包
* 变更管理员： 便于管理权交接 防止单一地址泄密增加安全性
* 变更各种交易收费费率： 这里要加判断，etherDelta 规定费率只能越设越低，给用户交易信心。 其中还有一些特殊规定， 交易购买手续费率必须要比返点费率大，否则就是赔钱做交易；
* 充值eth功能， 充值函数通过payable控制，只收eth， 充值修改状态成功后触发 充值事件，告知前端/用户充值成功
* 充值代币功能：
  * 需要判断币不是eth
  * 然后判断转账是否成功
  * 修改记账本
  * 触发充值事件
* 提现eth：
  * 先检查用户在合约里面的余额: `require(tokens[address(0)][msg.sender] >= amount);`
  * 合约中关于金额存储的状态修改
  * 给用户EOA打款方法： `(bool success, ) = msg.sender.call{value: amount}("");`
  * 校验是否转账成功，不成功通过require触发状态回滚： `require(success, "withdraw failed.");`
  * 触发对应的提现事件
* 提现代币：
  * 确认用户传递的币token不是eth
  * 检查余额
  * 修改记账本
  * 调代币的transfer执行转出
  * 触发提现事件
* 查询某个币下面某用户的额度， 直接返回记账本的映射即可
* 
